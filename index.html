<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>✨kiraの博客</title>
<meta name=description content="This is kira's blog"><meta name=author content><link rel=canonical href=https://kira-96.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.026333dcafeaf3c82b8515026af0a6531c530abffdaf73d32779337b0ace14c0.css integrity="sha256-AmMz3K/q88grhRUCavCmUxxTCr/9r3PTJ3kzewrOFMA=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-32x32.png><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-180x180.png><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-76x76.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kira-96.github.io/index.xml><link rel=alternate type=application/json href=https://kira-96.github.io/index.json><link rel=alternate hreflang=zh href=https://kira-96.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=manifest href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/manifest.json><script src=https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta property="og:url" content="https://kira-96.github.io/"><meta property="og:site_name" content="✨kiraの博客"><meta property="og:title" content="✨kiraの博客"><meta property="og:description" content="This is kira's blog"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="✨kiraの博客"><meta name=twitter:description content="This is kira's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"✨kiraの博客","url":"https://kira-96.github.io/","description":"This is kira's blog","logo":"https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico","sameAs":["https://github.com/kira-96/","https://space.bilibili.com/9258847","index.xml"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kira-96.github.io/ accesskey=h title="✨kiraの博客 (Alt + H)">✨kiraの博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kira-96.github.io/ title=🏠主页><span class=active>🏠主页</span></a></li><li><a href=https://kira-96.github.io/notes/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://kira-96.github.io/search/ title=🔍️搜索><span>🔍️搜索</span></a></li><li><a href=https://kira-96.github.io/archives/ title=🗃️存档><span>🗃️存档</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>✨kiraの博客🎐</h1></header><div class=entry-content>欢迎来到我的博客🎉</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/kira-96/ target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://space.bilibili.com/9258847 target=_blank rel="noopener noreferrer me" title=Bilibili><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round"><rect x="1.3333" y="6" width="21.333" height="15.333" rx="4" ry="4"/><path d="m8 12.4v1.2"/><path d="m16 12.4v1.2"/><path d="m5.8853 2.6667L8.552 5.3334"/><path d="m18.115 2.6667-2.6667 2.6667"/></svg>
</a><a href=index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>个人常用软件分享</h2></header><div class=entry-content><p>音乐 Listen1 音乐播放器 [Windows/Linux/MacOS/Android]
YesPlayMusic 高颜值的第三方网易云播放器 [Windows/Linux/MacOS]
AIMP [Windows/Android]
Dopamine [Windows]
视频 PotPlayer [Windows]
MPC-BE [Windows]
QQ影音 [Window/MacOS/Android/iOS]
MX Player [Android]
美图下载 Pixiviz
pixivFANBOX
SauceNAO
PixEz [Android/iOS]
下载 Flud 种子下载器 [Android]
Internet Download Manager [Windows]
Free Download Manager [Windows/MacOS/Linux/Android]
Motrix [Windows/MacOS/Linux]
截图、录屏 PixPin [Windows/MacOS]
Snipaste [Windows/MacOS]
GifCam [Windows]
VeryCapture [Windows]
...</p></div><footer class=entry-footer><span title='2020-02-22 10:43:10 +0800 +0800'>二月 22, 2020</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;281 字</footer><a class=entry-link aria-label="post link to 个人常用软件分享" href=https://kira-96.github.io/posts/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Qt5编写Qt Quick2插件</h2></header><div class=entry-content><p>前言 最近在试着把自定义的QML控件封装成插件供其他程序调用，由于我使用的还是Qt5，在构建的过程中遇到不少问题，这里做一下简单汇总。
新建项目 新建库→Qt Quick2 Extension Plugin，Qt 5版本仅支持使用QMake作为构建套件。Qt 6才支持使用CMake作为QML扩展插件的构建套件。
编写插件 例如，我新建了一个叫做Test的插件库，项目会自动创建一个TestPlugin的类，这个类继承自QQmlExtensionPlugin，我们需要重写它的两个虚函数。
1 2 3 4 5 6 7 8 9 10 11 12 /* testplugin.h */ #include &lt;QQmlExtensionPlugin> class TestPlugin : public QQmlExtensionPlugin { Q_OBJECT Q_PLUGIN_METADATA(IID QQmlExtensionInterface_iid) public: void registerTypes(const char *uri) Q_DECL_OVERRIDE; void initializeEngine(QQmlEngine *engine, const char *uri) Q_DECL_OVERRIDE; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* testplugin.cpp */ #include "testplugin.h" #include "myitem.h" #include &lt;qqml.h> void TestPlugin::registerTypes(const char *uri) { // @uri com.mycompany.qmlcomponents qmlRegisterType&lt;MyItem>(uri, 1, 0, "MyItem"); } void TestPlugin::initializeEngine(QQmlEngine *engine, const char *uri) { QQmlExtensionPlugin::initializeEngine(engine, uri); } 其中，MyItem就是我们自定义的控件。简单看一下示例代码：
...</p></div><footer class=entry-footer><span title='2025-03-13 10:23:47 +0800 +0800'>三月 13, 2025</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;711 字</footer><a class=entry-link aria-label="post link to Qt5编写Qt Quick2插件" href=https://kira-96.github.io/posts/qt5-quick2-extension-plugin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>QML控件访问EPICS过程变量的思路</h2></header><div class=entry-content><p>前言 写这篇文章的想法是使用自定义QML控件的方式访问EPICS过程变量，现有的Qt EPICS框架之前也介绍过了，还有配套的QEGui工具，框架的基本功能已经比较完善，但实际使用过程中还是遇到了一些问题。我总结有以下2点：
QEGui工具只能加载基于Widget的.ui界面文件，文件只能包含布局、控件和控件属性，不能嵌入代码（C++代码必须编译）。用户的操作（如：输入、点击按钮等）的相应槽函数封装在框架自定义的控件里实现，这样极大方便了用户的开发，用户只需要设计界面，填写变量名就可以实现变量访问，但相应的也失去了很大的灵活性，程序的功能变得很单一。
QEGui工具不一定符合实际开发过程中的需求，仅使用QEGui加载.ui界面，脱离了C++代码，程序很难实现用户想要的效果。而更好的选择是调用Qt EPICS框架动态库提供的控件，结合C++代码开发应用程序，但却不得不进行编译操作。
那么，有没有更好的基于Qt的EPICS框架方案呢？
刚好最近我也学习实践了QML相关的内容，这种前后端分离开发的方式给了我一些灵感。我们完全可以在Qt EPICS框架的基础上，实现自定义QML控件访问EPICS过程变量，用户使用QML编写界面，调用自定义QML控件即可，可以实现和Qt EPICS框架加载.ui界面文件类似的功能。但QML在动画、3D显示等方面明显具有优势，还有一点是基于Widget的.ui界面文件不具备的：QML本身可以嵌入javascript函数，动态控制界面的显示、切换等，甚至可以实现和底层C++接口的交互。而QML本身也不需要进行编译，完全可以只使用QML语言实现程序开发，且具有很高灵活性。
实现思路 Qt EPICS 框架提供了QCaObject类访问EPICS过程变量，但该类几乎是完全为QEWidget服务的，并没有声明属性（property），无法直接在QML中使用。
所以第1步需要对QCaObject做一层封装，将EPICS过程变量的字段声明为QPvObject类的属性，然后就可以在QML中访问EPICS过程变量了。
第2步是将QPvObject封装进自定义的QML控件QmlPvControl，实现数据的显示、输入等操作。
第3步将QmlPvControl导入（import）到QML文件，在外部QML文件中使用自定义控件。
代码示例 由于完整的代码较多，这里只放部分代码。
QPvObject类的定义
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 /* qpvobject.h */ class QPvObject : public QObject { Q_OBJECT public: enum epicsAlarmSeverity { NO_ALARM, /**&lt; No alarm */ MINOR_ALARM, /**&lt; Minor alarm severity */ MAJOR_ALARM, /**&lt; Major alarm severity */ INVALID_ALARM, /**&lt; Invalid alarm severity */ ALARM_NSEV /**&lt; Number of alarm severities */ }; Q_ENUM(epicsAlarmSeverity) enum pvConnectionMode { NONE, WR_ONLY, /**&lt; Write only */ RD_ONCE, /**&lt; Read once */ MONITOR /**&lt; Read and Write */ }; Q_ENUM(pvConnectionMode) private: Q_PROPERTY(QString pvName READ pvName WRITE setPvName NOTIFY pvNameChanged FINAL) Q_PROPERTY(QVariant value READ value WRITE setValue NOTIFY valueChanged FINAL) Q_PROPERTY(QPvObject::pvConnectionMode mode READ mode WRITE setMode NOTIFY modeChanged FINAL) Q_PROPERTY(QString hostName READ hostName NOTIFY hostNameChanged FINAL) Q_PROPERTY(QString fieldType READ fieldType NOTIFY fieldTypeChanged FINAL) Q_PROPERTY(QString descriptor READ descriptor NOTIFY descriptorChanged FINAL) Q_PROPERTY(QString egu READ egu NOTIFY eguChanged FINAL) Q_PROPERTY(QCaDateTime dateTime READ dateTime NOTIFY dateTimeChanged FINAL) Q_PROPERTY(quint16 status READ status NOTIFY statusChanged FINAL) Q_PROPERTY(QPvObject::epicsAlarmSeverity severity READ severity NOTIFY severityChanged FINAL) Q_PROPERTY(QString statusName READ statusName NOTIFY statusNameChanged FINAL) Q_PROPERTY(QString severityName READ severityName NOTIFY severityNameChanged FINAL) Q_PROPERTY(quint32 hostElementCount READ hostElementCount NOTIFY hostElementCountChanged FINAL) Q_PROPERTY(quint32 dataElementCount READ dataElementCount NOTIFY dataElementCountChanged FINAL) Q_PROPERTY(bool readAccess READ readAccess NOTIFY readAccessChanged FINAL) Q_PROPERTY(bool writeAccess READ writeAccess NOTIFY writeAccessChanged FINAL) public: QString pvName() const; QVariant value() const; QPvObject::pvProtocol protocol() const; QPvObject::pvConnectionMode mode() const; QString hostName() const; QString fieldType() const; QString descriptor() const; QString egu() const; const QCaDateTime& dateTime() const; quint16 status() const; QPvObject::epicsAlarmSeverity severity() const; QString statusName() const; QString severityName() const; quint32 hostElementCount() const; quint32 dataElementCount() const; bool readAccess() const; bool writeAccess() const; public Q_SLOTS: virtual void setPvName(const QString &amp;pvname) = 0; virtual void setValue(const QVariant &amp;value) = 0; virtual void setMode(const QPvObject::pvConnectionMode &amp;mode); Q_SIGNALS: void pvNameChanged(const QString&); void valueChanged(const QVariant&); void protocolChanged(const QPvObject::pvProtocol&); void modeChanged(const QPvObject::pvConnectionMode&); void dateTimeChanged(const QCaDateTime&); void fieldTypeChanged(const QString&); void descriptorChanged(const QString&); void eguChanged(const QString&); void hostNameChanged(const QString&); void statusChanged(const quint16); void severityChanged(const QPvObject::epicsAlarmSeverity); void statusNameChanged(const QString); void severityNameChanged(const QString); void hostElementCountChanged(const quint32); void dataElementCountChanged(const quint32); void readAccessChanged(const bool); void writeAccessChanged(const bool); protected: QPointer&lt;qcaobject::QCaObject> m_caobject; // ... }; 注意到QPvObject类有两个虚函数setPvName和setValue，这两个函数需要子类实现。
...</p></div><footer class=entry-footer><span title='2025-02-20 16:27:36 +0800 +0800'>二月 20, 2025</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;900 字</footer><a class=entry-link aria-label="post link to QML控件访问EPICS过程变量的思路" href=https://kira-96.github.io/posts/qml%E6%8E%A7%E4%BB%B6%E8%AE%BF%E9%97%AEepics%E8%BF%87%E7%A8%8B%E5%8F%98%E9%87%8F%E7%9A%84%E6%80%9D%E8%B7%AF/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPICS PVAccess 使用方法研究</h2></header><div class=entry-content><p>前言 EPICS V7 中引入了 pvAccess、pvData等相关模块，增加了对结构化数据的支持。 pvData (Process Variable Data, 过程变量数据) 是EPICS核心软件的一部分，它是一个运行时类型系统，具有用于处理结构化数据的序列化和内省（introspection）功能。
pvData有四种类型的数据字段：scalar、scalarArray、structure和structureArray。scalar（标量）可以是以下标量类型之一：Boolean、Byte、Short、Int、Long、U(nsigned)Byte、Unsigned Short、Unsigned Int、Unsigned Long、Float、Double和String。scalarArray是一维数组，元素类型为任何标量类型。structure（结构体）是一组有序的字段，其中每个字段都有一个名称和类型。structureArray是结构体数组，由于字段可以是结构，因此可以创建复杂的结构。
QSRV是一个使用PVAccess协议的网络服务器，在EPICS IOC进程中运行，允许客户端请求访问其中的过程变量（PV）。 PVXS是一个PVAccess协议客户端/服务器的程序模块。功能等同于 pvDataCPP，并希望最终能取代CPP模块。
PVAccess 默认端口：5076
环境变量表：
Variable Client Server EPICS_PVA_ADDR_LIST × × EPICS_PVAS_BEACON_ADDR_LIST × EPICS_PVA_AUTO_ADDR_LIST × × EPICS_PVAS_AUTO_BEACON_ADDR_LIST × EPICS_PVAS_INTF_ADDR_LIST × EPICS_PVA_SERVER_PORT × × EPICS_PVAS_SERVER_PORT × EPICS_PVA_BROADCAST_PORT × × EPICS_PVAS_BROADCAST_PORT × EPICS_PVAS_IGNORE_ADDR_LIST × EPICS_PVA_CONN_TMO × × EPICS_PVA_NAME_SERVERS × 快速使用 使用softIocPVA软件。
1 2 3 4 5 6 7 8 9 cat &lt;&lt;EOF > p2pexample.db record(calc, "p2p:example:counter") { field(INPA, "p2p:example:counter") field(CALC, "A+1") field(SCAN, "1 second") } EOF ./bin/linux-x86_64/softIocPVA -d p2pexample.db 添加 QSRV 到 IOC 如果使用EPICS V7创建IOC，那么可以看到程序已经默认添加了QSRV到IOC中。如：
...</p></div><footer class=entry-footer><span title='2025-01-13 10:40:45 +0800 +0800'>一月 13, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;566 字</footer><a class=entry-link aria-label="post link to EPICS PVAccess 使用方法研究" href=https://kira-96.github.io/posts/epics-pvaccess-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPICS IOC GPIO设备支持的使用</h2></header><div class=entry-content><p>前言 之前讲过Linux的GPIO操作，主要是使用程序访问Linux系统提供的用户空间接口。这次是介绍如何使用EPICS IOC控制GPIO的输入或输出。EPICS有许多设备支持程序，其中就包括Linux GPIO驱动，对于某些需要使用EPICS控制设备GPIO的情况十分有用。
编译GPIO设备支持模块 使用到的软件模块 epics-base - (launchpad.net) / epics-base/epics-base / EPICS Base (anl.gov)
ffeldbauer/epics-devgpio: EPICS device support to control GPIOs on the BeagleBone Black / Raspberry Pi via the /sys/class/gpio interface
需要先安装好EPICS Base.
编译 devgpio 注意：gpio设备支持用到了Linux 5.x 内核提供的gpio应用程序接口。
Version 2 of this device support uses the new V2 ABI for GPIO character device (c.f. /usr/include/linux/gpio.h) which was introduced in Kernel 5.x.
如果你使用的是旧版的linxu内核，可能需要使用R1-0-6。
交叉编译时gpio.h的路径：${SDKTARGETSYSROOT}/usr/include/linux/gpio.h
编译步骤：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd epics-devgpio touch configure/RELEASE.local vi configure/RELEASE.local # 修改成和EPICS Base一样的架构 # EPICS_HOST_ARCH=linux-loong64 # EPICS Base路径（示例） EPICS_BASE=/home/ubuntu/epics/base-7.0.8.1 # 直接编译 # make # 交叉编译（示例） # make LD=loongarch64-linux-gnu-ld CC=loongarch64-linux-gnu-gcc CCC=loongarch64-linux-gnu-g++ make 使用GPIO的设备支持库 为IOC程序添加GPIO设备支持，和其他设备支持程序使用方法一样。
...</p></div><footer class=entry-footer><span title='2024-12-02 09:45:59 +0800 +0800'>十二月 2, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;306 字</footer><a class=entry-link aria-label="post link to EPICS IOC GPIO设备支持的使用" href=https://kira-96.github.io/posts/epics-ioc-gpio-device-support/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPICS IOC 访问安全</h2></header><div class=entry-content><p>原文：IOC Access Security
功能 访问安全功能用于保护IOC数据库，限制来自未经授权的CA或pvAccess客户端访问。访问安全性基于以下几点：
Who 客户端的用户ID（Channel Access/pvAccess）。
Where 用户登录的主机 ID。客户端运行的主机，但不会分辨用户是本地用户或远程登录到主机的用户。
What 记录的各个字段都受到保护。每条记录都有一个字段包含记录的访问安全组（ASG）。每个字段都有一个访问安全级别（ASL0或ASL1）。安全级别在记录定义文件（.dbd）中定义。
When 访问规则可以包含类似于CALC Record的输入计算。
定义 ASL 访问安全级别
ASG 访问安全组
UAG 用户访问组
HAG 主机访问组
快速上手 为了启用特定 IOC 的访问安全性，需要完成以下操作：
创建访问安全文件（.acf） 可能需要修改IOC数据库 记录实例可能需要设置访问安全组ASG字段。如果ASG为空，记录将会使用“DEFAULT”访问安全组。
访问安全文件可以在iocInit之后通过asSubInit和asSubProcess作为关联的子程序重新加载。将值1写入此记录将导致重新加载。
必须启动脚本在的iocInit之前包含以下命令：
1 2 3 4 asSetFilename("/full/path/to/accessSecurityFile") /* 下面是一个可选命令 */ /* 使用宏替换 */ asSetSubstitutions("var1=sub1,var2=sub2,...") 如果在iocInit之前未执行asSetFilename，就不会启用访问安全限制。
如果给定asSetFilename，但在首次初始化访问安全性时发生错误，则对该IOC的所有访问都会被拒绝。
成功启动访问安全性后，尝试重新启动时出现错误，将会保持上次的访问安全配置。
启动IOC并启用访问安全后，可以通过asSetFilename、asSetSubstitutions和asInit来更改访问安全规则。也可以使用函数asInitialize、asInitFile和asInitFP。
在启动IOC之后重新初始化访问安全配置操作是“非常昂贵”的操作，尽量不要这样做。
访问安全配置文件 本节介绍包含用户访问组（UAG）、主机访问组（HAG）和访问安全组（ASG）。IOC会读取访问配置文件（建议使用扩展名.acf）然后创建访问配置数据库。首先给出一个简单的例子，然后是完整的语法描述。
简单示例
1 2 3 4 5 6 7 8 9 UAG(uag) {user1,user2} HAG(hag) {host1,host2} ASG(DEFAULT) { RULE(1,READ) RULE(1,WRITE) { UAG(uag) HAG(hag) } } 上面的规则提供了无限制的读权限（READ），而位于主机host1和host2上的用户user1和user2则拥有写权限（WRITE）。
...</p></div><footer class=entry-footer><span title='2024-03-18 09:52:05 +0800 +0800'>三月 18, 2024</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;580 字</footer><a class=entry-link aria-label="post link to EPICS IOC 访问安全" href=https://kira-96.github.io/posts/epics-ioc-access-security/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>龙芯开发板移植 IgH EtherCAT Master</h2></header><div class=entry-content><p>前言 IgH EtherCAT Master 是一个开源的EtherCAT主站驱动程序，用于管理EtherCAT从站设备，支持Linux操作系统，工控上使用的比较多。
dls ethercat是由英国钻石光源开发的用于 EPICS 控制系统 EtherCAT 设备的支持程序，基于 IgH Master 主站程序开发，实现对 EtherCAT 总线设备的读写。
交叉编译环境：Ubuntu
运行开发板：龙芯2K0500金龙开发板
内核版本：Linux LS-GD 5.10.0-rt17.lsgd #1 PREEMPT_RT
相关软件包下载地址 epics-base - (launchpad.net) / epics-base/epics-base / EPICS Base (anl.gov)
epics-modules/asyn: EPICS module for driver and device support
epics-modules/busy: APS BCDA synApps module: busy
epics-modules/autosave: APS BCDA synApps module: autosave
dls-controls/ethercat: EPICS support to read/write to ethercat based hardware
IgH EtherCAT Master for Linux
PREEMPT RT patch
配置交叉编译环境 关于这一节，之前的文章已经详细讲过，参考配置交叉编译环境。
...</p></div><footer class=entry-footer><span title='2024-02-23 12:54:31 +0800 +0800'>二月 23, 2024</span>&nbsp;·&nbsp;14 分钟&nbsp;·&nbsp;2863 字</footer><a class=entry-link aria-label="post link to 龙芯开发板移植 IgH EtherCAT Master" href=https://kira-96.github.io/posts/%E9%BE%99%E8%8A%AF%E5%BC%80%E5%8F%91%E6%9D%BF%E7%A7%BB%E6%A4%8Digh-ethercat-master/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPICS的MODBUS模块的编译和使用</h2></header><div class=entry-content><p>前言 MODBUS是一种应用层消息传递协议，通常用于 I/O 系统通信和可编程逻辑控制器（PLC）通信。
链接类型 描述 MODBUS TCP TCP/IP 使用502端口 MODBUS RTU RTU通常通过串行通信链路运行，即RS-232、 RS-422 或 RS-485。RTU 使用额外的 CRC 进行数据包检查。协议直接将每个字节作为 8 个数据位传输，因此使用“二进制” 而不是 ASCII 编码。使用串行链路开始和结束时，消息帧是按时间而不是按特定字符检测的。 MODBUS ASCII 串行协议，通常在串行通信链路上运行，即 RS-232、RS-422 或 RS-485。串行 ASCII 使用额外的 LRC 数据包检查。该协议将每个字节编码为 2 个 ASCII 字符。消息帧的开始和结束由特定字符检测 （“:” 开始消息，CR/LF 结束消息）。该协议效率低于 Modbus RTU，但在某些环境中可能更可靠。 Modbus 提供对以下 4 种类型的数据的访问：
主表 对象类型 访问 说明 离散输入 1bit 只读 这种类型的数据可以由 I/O 系统提供。 线圈 1bit 读写 此类数据可由应用程序更改。 输入寄存器 16位字(2字节) 只读 这种类型的数据可以由 I/O 系统提供。 保持寄存器 16位字(2字节) 读写 此类数据可由应用程序更改。 Modbus 通信由从 Modbus 客户端发送到 Modbus 服务器的请求消息组成。服务器使用响应消息进行回复。Modbus 请求消息包含：
...</p></div><footer class=entry-footer><span title='2024-01-02 14:38:38 +0800 +0800'>一月 2, 2024</span>&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;1276 字</footer><a class=entry-link aria-label="post link to EPICS的MODBUS模块的编译和使用" href=https://kira-96.github.io/posts/build-epics-module-modbus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>交叉编译EPICS和IOC</h2></header><div class=entry-content><p>前言 之前已经讲过在龙芯3A5000(loongarch64)上编译运行EPICS，不过这种情况只适用于有完整开发环境的情况下进行编译。一些时候，我们只有编译器，而缺少make，perl等工具，比如一些开发板厂商提供的开发套件。这种情况下，就需要通过交叉编译(cross-compiling)的方式来编译EPICS。
这里以龙芯金龙2K500先锋开发板为例，我们使用Ubuntu-20.04作为构建系统，详细讲解如何构建出可以在开发板上运行的EPICS工具包，并部署在开发板上。
由于开发板上没有开发环境，即使编译出目标平台的EPICS Base，我们依然不能直接在开发板上创建和编译IOC。所以，我们还是使用Ubuntu-20.04作为构建系统，创建并编译IOC，最后在开发板上运行。
配置交叉编译环境 关于这一节，之前的文章已经详细讲过，参考配置交叉编译环境。
如果你使用的是其他开发套件，请按照开发手册安装配置好环境。
编译 EPICS Base 首先，下载、解压Base，参考以前的文章。
在龙芯3A5000(loongarch64)上编译运行EPICS中我已经详细讲解了如何在龙架构上编译EPICS，这次，需要在原来对源码修改的基础上，再增加对交叉编译的支持。
添加configure/os/CONFIG.linux-x86_64.linux-loong64
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # CONFIG.linux-x86_64.linux-loong64 # # Definitions for linux-x86_64 host - linux-loong64 target builds # Sites may override these in CONFIG_SITE.linux-x86_64.linux-loong64 #------------------------------------------------------- VALID_BUILDS = Ioc Command GNU_TARGET = loongarch64-linux-gnu # prefix of compiler tools CMPLR_SUFFIX = CMPLR_PREFIX = $(addsuffix -,$(GNU_TARGET)) # Provide a link-time path for readline if needed OP_SYS_INCLUDES += $(READLINE_DIR:%=-I%/include) READLINE_LDFLAGS = $(READLINE_DIR:%=-L%/lib) RUNTIME_LDFLAGS_READLINE_YES_NO = $(READLINE_DIR:%=-Wl,-rpath,%/lib) RUNTIME_LDFLAGS += \ $(RUNTIME_LDFLAGS_READLINE_$(LINKER_USE_RPATH)_$(STATIC_BUILD)) SHRLIBDIR_LDFLAGS += $(READLINE_LDFLAGS) PRODDIR_LDFLAGS += $(READLINE_LDFLAGS) # Library flags STATIC_LDFLAGS_YES= -Wl,-Bstatic STATIC_LDFLAGS_NO= STATIC_LDLIBS_YES= -Wl,-Bdynamic STATIC_LDLIBS_NO= 添加configure/os/CONFIG_SITE.linux-x86_64.linux-loong64
...</p></div><footer class=entry-footer><span title='2023-12-12 16:26:35 +0800 +0800'>十二月 12, 2023</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;712 字</footer><a class=entry-link aria-label="post link to 交叉编译EPICS和IOC" href=https://kira-96.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91epics%E5%92%8Cioc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux LED子系统</h2></header><div class=entry-content><p>前言 Linux 内核提供了丰富的设备驱动接口，其中GPIO和LED属于是最基本的一类了。之前就已经讲过用户空间下的GPIO读写操作，LED设备的操作也基本相同。其实完全可以使用GPIO驱动去控制LED，但LED的驱动针对LED提供了更多的功能，一起来看一下吧。
配置设备树 设备树中的LED节点配置，例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* kernel/arch/arm/boot/dts/imx6ul-14x14-evk-c-emmc.dts */ leds { compatible = "gpio-leds"; pinctrl-names = "default"; status = "okay"; led1{ label = "led1"; gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led2{ label = "led2"; gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led3{ label = "heartbeat"; gpios = &lt;&amp;gpio5 5 GPIO_ACTIVE_LOW>; linux,default-trigger = "heartbeat"; }; }; 节点属性说明：
label：LED设备的名字，名字必须是唯一的。如果没有设置，则会使用节点的名字。
gpios：GPIO的编号，以及高低电平设置，GPIO_ACTIVE_LOW低电平点亮，GPIO_ACTIVE_HIGH高电平点亮。
default-state：默认状态，on/off。
linux,default-trigger：设置LED的触发器。backlight-背光灯，heartbeat-心跳灯，timer-定时，default-on-默认开状态，disk-activity-硬盘状态，gpio，none。
用户空间下的LED操作 注意：以下操作都需要root权限！
用户空间下的GPIO文件系统接口在/sys/class/leds/{label}目录下。
...</p></div><footer class=entry-footer><span title='2023-11-11 15:45:11 +0800 +0800'>十一月 11, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;185 字</footer><a class=entry-link aria-label="post link to Linux LED子系统" href=https://kira-96.github.io/posts/linux-led%E5%AD%90%E7%B3%BB%E7%BB%9F/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://kira-96.github.io/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>© 2019-2025 <a href=/>kira&rsquo;s blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>