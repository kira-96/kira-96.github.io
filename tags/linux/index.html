<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux | ✨kiraの博客</title>
<meta name=keywords content><meta name=description content="This is kira's blog"><meta name=author content><link rel=canonical href=https://kira-96.github.io/tags/linux/><link crossorigin=anonymous href=/assets/css/stylesheet.c4283cee00bc960e202a2bc7c1895ffdaaa8a142b5b90627b331e5eb551a8cf8.css integrity="sha256-xCg87gC8lg4gKivHwYlf/aqooUK1uQYnszHl61UajPg=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-32x32.png><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-180x180.png><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-76x76.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kira-96.github.io/tags/linux/index.xml><link rel=alternate hreflang=zh href=https://kira-96.github.io/tags/linux/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=manifest href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/manifest.json><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css><script src=https://fastly.jsdelivr.net/npm/live2d-widgets@0/autoload.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta property="og:url" content="https://kira-96.github.io/tags/linux/"><meta property="og:site_name" content="✨kiraの博客"><meta property="og:title" content="Linux"><meta property="og:description" content="This is kira's blog"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux"><meta name=twitter:description content="This is kira's blog"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kira-96.github.io/ accesskey=h title="✨kiraの博客 (Alt + H)">✨kiraの博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kira-96.github.io/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://kira-96.github.io/notes/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://kira-96.github.io/search/ title=🔍️搜索><span>🔍️搜索</span></a></li><li><a href=https://kira-96.github.io/archives/ title=🗃️存档><span>🗃️存档</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://kira-96.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://kira-96.github.io/tags/>Tags</a></div><h1>Linux
<a href=/tags/linux/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux CPU核心隔离
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>CPU隔离主要是为了确保关键进程获得更高的性能，减少干扰。常见的隔离方法有cgroups、taskset、isolcpus内核参数，还有实时内核（PREEMPT RT）配置。还有CPU亲和性、IRQ屏蔽技术。
isolcpus：在启动内核时隔离某些CPU核心，防止普通进程使用。但需要结合cgroups或taskset来分配进程到隔离核心。 nohz_full：在隔离核心禁用时钟中断（Tickless 模式）。 rcu_nocbs：将 RCU 回调任务移出隔离核心。 修改内核启动参数
主要参数：ioslcpus=? nohz_full=? rcu_nocbs=?
例： earlycon console=tty console=ttyS0,115200 isolcpus=1,2 nohz_full=1,2 rcu_nocbs=1,2 acpi=off rdinit=/sbin/init rootdelay=5 root=/dev/sda1
通过GRUB配置
/etc/default/grub ▼ 1 2 # 添加isolcpus参数 GRUB_CMDLINE_LINUX="isolcpus=1,2 nohz_full=1,2 rcu_nocbs=1,2" 修改完成后更新GRUB配置：sudo update-grub
设置进程CPU亲和性
shell ▼ 1 2 3 4 # 启动时绑定到核心 1,2 taskset -a -c 1,2 ./st.cmd # 修改运行中进程的 CPU 亲和性 taskset -cp &lt;core_list> &lt;pid> IgH EtherCAT驱动设置CPU亲和性 在脚本中添加启动参数run_on_cpu=?，例：
/sbin/ethercatctl ▼ 1 2 3 4 5 6 7 8 9 10 11 ## /sbin/ethercatctl ... # load master module if ! ${MODPROBE} ${MODPROBE_FLAGS} ec_master \ main_devices="${DEVICES}" backup_devices="${BACKUPS}" run_on_cpu=1; then exit 1 fi ... ...</p></div><footer class=entry-footer><span title='2025-03-13 14:59:45 +0800 +0800'>三月 13, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;146 字</footer><a class=entry-link aria-label="post link to Linux CPU核心隔离" href=https://kira-96.github.io/notes/linux-cpu-isolation/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPICS IOC 使用 SNCSEQ
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>IOC 配置SNCSEQ：
configure/RELEASE.local ▼ 1 2 3 4 5 EPICS_BASE = /path/to/your/build/of/epics-base SUPPORT = ${EPICS_BASE}/../epics-modules PVXS = ${SUPPORT}/pvxs # 添加 SNCSEQ SNCSEQ = ${SUPPORT}/sequencer example工程中相关的代码：
Makefile ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # example/iocExampleApp/src/Makefile ... # Link in the code from our support library iocExample_LIBS += iocExampleSupport # To build SNL programs, SNCSEQ must be defined # in the &lt;top>/configure/RELEASE file ifneq ($(SNCSEQ),) # Build sncExample into iocExampleSupport sncExample_SNCFLAGS += +r iocExample_DBD += sncExample.dbd # A .stt sequence program is *not* pre-processed: iocExampleSupport_SRCS += sncExample.stt iocExampleSupport_LIBS += seq pv iocExample_LIBS += seq pv # Build sncProgram as a standalone program PROD_HOST += sncProgram sncProgram_SNCFLAGS += +m # A .st sequence program *is* pre-processed: sncProgram_SRCS += sncProgram.st sncProgram_LIBS += seq pv sncProgram_LIBS += $(EPICS_BASE_HOST_LIBS) endif ... sncExample.dbd ▼ 1 2 3 4 5 # The name below is derived from the name of the SNL program # inside the source file, not from its filename. Here the # program is called sncExample, but is compiled in both the # sncExample.stt and sncProgram.st source files. registrar(sncExampleRegistrar) sncProgram.st ▼ 1 #include "../sncExample.stt" sncExample.stt ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 program sncExample double v; assign v to "{user}:aiExample"; monitor v; ss ss1 { state init { when (delay(10)) { printf("sncExample: Startup delay over\n"); } state low } state low { when (v > 5.0) { printf("sncExample: Changing to high\n"); } state high } state high { when (v &lt;= 5.0) { printf("sncExample: Changing to low\n"); } state low } } 修改启动脚本，在IOC启动时运行SNL程序：
...</p></div><footer class=entry-footer><span title='2025-01-13 10:45:01 +0800 +0800'>一月 13, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;317 字</footer><a class=entry-link aria-label="post link to EPICS IOC 使用 SNCSEQ" href=https://kira-96.github.io/notes/epics-ioc-%E4%BD%BF%E7%94%A8-sncseq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPICS PVAccess 使用方法研究</h2></header><div class=entry-content><p>前言 EPICS V7 中引入了 pvAccess、pvData等相关模块，增加了对结构化数据的支持。 pvData (Process Variable Data, 过程变量数据) 是EPICS核心软件的一部分，它是一个运行时类型系统，具有用于处理结构化数据的序列化和内省（introspection）功能。
pvData有四种类型的数据字段：scalar、scalarArray、structure和structureArray。scalar（标量）可以是以下标量类型之一：Boolean、Byte、Short、Int、Long、U(nsigned)Byte、Unsigned Short、Unsigned Int、Unsigned Long、Float、Double和String。scalarArray是一维数组，元素类型为任何标量类型。structure（结构体）是一组有序的字段，其中每个字段都有一个名称和类型。structureArray是结构体数组，由于字段可以是结构，因此可以创建复杂的结构。
QSRV是一个使用PVAccess协议的网络服务器，在EPICS IOC进程中运行，允许客户端请求访问其中的过程变量（PV）。 PVXS是一个PVAccess协议客户端/服务器的程序模块。功能等同于 pvDataCPP，并希望最终能取代CPP模块。
PVAccess 默认端口：5076
环境变量表：
Variable Client Server EPICS_PVA_ADDR_LIST × × EPICS_PVAS_BEACON_ADDR_LIST × EPICS_PVA_AUTO_ADDR_LIST × × EPICS_PVAS_AUTO_BEACON_ADDR_LIST × EPICS_PVAS_INTF_ADDR_LIST × EPICS_PVA_SERVER_PORT × × EPICS_PVAS_SERVER_PORT × EPICS_PVA_BROADCAST_PORT × × EPICS_PVAS_BROADCAST_PORT × EPICS_PVAS_IGNORE_ADDR_LIST × EPICS_PVA_CONN_TMO × × EPICS_PVA_NAME_SERVERS × 快速使用 使用softIocPVA软件。
shell ▼ 1 2 3 4 5 6 7 8 9 cat &lt;&lt;EOF > p2pexample.db record(calc, "p2p:example:counter") { field(INPA, "p2p:example:counter") field(CALC, "A+1") field(SCAN, "1 second") } EOF ./bin/linux-x86_64/softIocPVA -d p2pexample.db 添加 QSRV 到 IOC 如果使用EPICS V7创建IOC，那么可以看到程序已经默认添加了QSRV到IOC中。如：
...</p></div><footer class=entry-footer><span title='2025-01-13 10:40:45 +0800 +0800'>一月 13, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;598 字</footer><a class=entry-link aria-label="post link to EPICS PVAccess 使用方法研究" href=https://kira-96.github.io/posts/epics-pvaccess-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPICS IOC GPIO设备支持的使用</h2></header><div class=entry-content><p>前言 之前讲过Linux的GPIO操作，主要是使用程序访问Linux系统提供的用户空间接口。这次是介绍如何使用EPICS IOC控制GPIO的输入或输出。EPICS有许多设备支持程序，其中就包括Linux GPIO驱动，对于某些需要使用EPICS控制设备GPIO的情况十分有用。
编译GPIO设备支持模块 使用到的软件模块 epics-base - (launchpad.net) / epics-base/epics-base / EPICS Base (anl.gov)
ffeldbauer/epics-devgpio: EPICS device support to control GPIOs on the BeagleBone Black / Raspberry Pi via the /sys/class/gpio interface
需要先安装好EPICS Base.
编译 devgpio 注意：gpio设备支持用到了Linux 5.x 内核提供的gpio应用程序接口。
Version 2 of this device support uses the new V2 ABI for GPIO character device (c.f. /usr/include/linux/gpio.h) which was introduced in Kernel 5.x.
如果你使用的是旧版的linxu内核，可能需要使用R1-0-6。
交叉编译时gpio.h的路径：${SDKTARGETSYSROOT}/usr/include/linux/gpio.h
编译步骤：
shell ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 cd epics-devgpio touch configure/RELEASE.local vi configure/RELEASE.local # 修改成和EPICS Base一样的架构 # EPICS_HOST_ARCH=linux-loong64 # EPICS Base路径（示例） EPICS_BASE=/home/ubuntu/epics/base-7.0.8.1 # 直接编译 # make # 交叉编译（示例） # make LD=loongarch64-linux-gnu-ld CC=loongarch64-linux-gnu-gcc CCC=loongarch64-linux-gnu-g++ make 使用GPIO的设备支持库 为IOC程序添加GPIO设备支持，和其他设备支持程序使用方法一样。
...</p></div><footer class=entry-footer><span title='2024-12-02 09:45:59 +0800 +0800'>十二月 2, 2024</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;326 字</footer><a class=entry-link aria-label="post link to EPICS IOC GPIO设备支持的使用" href=https://kira-96.github.io/posts/epics-ioc-gpio-device-support/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPICS IOC 访问安全</h2></header><div class=entry-content><p>原文：IOC Access Security
功能 访问安全功能用于保护IOC数据库，限制来自未经授权的CA或pvAccess客户端访问。访问安全性基于以下几点：
Who 客户端的用户ID（Channel Access/pvAccess）。
Where 用户登录的主机 ID。客户端运行的主机，但不会分辨用户是本地用户或远程登录到主机的用户。
What 记录的各个字段都受到保护。每条记录都有一个字段包含记录的访问安全组（ASG）。每个字段都有一个访问安全级别（ASL0或ASL1）。安全级别在记录定义文件（.dbd）中定义。
When 访问规则可以包含类似于CALC Record的输入计算。
定义 ASL 访问安全级别
ASG 访问安全组
UAG 用户访问组
HAG 主机访问组
快速上手 为了启用特定 IOC 的访问安全性，需要完成以下操作：
创建访问安全文件（.acf） 可能需要修改IOC数据库 记录实例可能需要设置访问安全组ASG字段。如果ASG为空，记录将会使用“DEFAULT”访问安全组。
访问安全文件可以在iocInit之后通过asSubInit和asSubProcess作为关联的子程序重新加载。将值1写入此记录将导致重新加载。
必须启动脚本在的iocInit之前包含以下命令：
st.cmd ▼ 1 2 3 4 asSetFilename("/full/path/to/accessSecurityFile") /* 下面是一个可选命令 */ /* 使用宏替换 */ asSetSubstitutions("var1=sub1,var2=sub2,...") 如果在iocInit之前未执行asSetFilename，就不会启用访问安全限制。
如果给定asSetFilename，但在首次初始化访问安全性时发生错误，则对该IOC的所有访问都会被拒绝。
成功启动访问安全性后，尝试重新启动时出现错误，将会保持上次的访问安全配置。
启动IOC并启用访问安全后，可以通过asSetFilename、asSetSubstitutions和asInit来更改访问安全规则。也可以使用函数asInitialize、asInitFile和asInitFP。
在启动IOC之后重新初始化访问安全配置操作是“非常昂贵”的操作，尽量不要这样做。
访问安全配置文件 本节介绍包含用户访问组（UAG）、主机访问组（HAG）和访问安全组（ASG）。IOC会读取访问配置文件（建议使用扩展名.acf）然后创建访问配置数据库。首先给出一个简单的例子，然后是完整的语法描述。
简单示例
accessSecurityFile.acf ▼ 1 2 3 4 5 6 7 8 9 UAG(uag) {user1,user2} HAG(hag) {host1,host2} ASG(DEFAULT) { RULE(1,READ) RULE(1,WRITE) { UAG(uag) HAG(hag) } } 上面的规则提供了无限制的读权限（READ），而位于主机host1和host2上的用户user1和user2则拥有写权限（WRITE）。
...</p></div><footer class=entry-footer><span title='2024-03-18 09:52:05 +0800 +0800'>三月 18, 2024</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;610 字</footer><a class=entry-link aria-label="post link to EPICS IOC 访问安全" href=https://kira-96.github.io/posts/epics-ioc-access-security/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>龙芯开发板移植 IgH EtherCAT Master</h2></header><div class=entry-content><p>前言 IgH EtherCAT Master 是一个开源的EtherCAT主站驱动程序，用于管理EtherCAT从站设备，支持Linux操作系统，工控上使用的比较多。
dls ethercat是由英国钻石光源开发的用于 EPICS 控制系统 EtherCAT 设备的支持程序，基于 IgH Master 主站程序开发，实现对 EtherCAT 总线设备的读写。
交叉编译环境：Ubuntu
运行开发板：龙芯2K0500金龙开发板
内核版本：Linux LS-GD 5.10.0-rt17.lsgd #1 PREEMPT_RT
相关软件包下载地址 epics-base - (launchpad.net) / epics-base/epics-base / EPICS Base (anl.gov)
epics-modules/asyn: EPICS module for driver and device support
epics-modules/busy: APS BCDA synApps module: busy
epics-modules/autosave: APS BCDA synApps module: autosave
dls-controls/ethercat: EPICS support to read/write to ethercat based hardware
IgH EtherCAT Master for Linux
PREEMPT RT patch
配置交叉编译环境 关于这一节，之前的文章已经详细讲过，参考配置交叉编译环境。
...</p></div><footer class=entry-footer><span title='2024-02-23 12:54:31 +0800 +0800'>二月 23, 2024</span>&nbsp;·&nbsp;14 分钟&nbsp;·&nbsp;2935 字</footer><a class=entry-link aria-label="post link to 龙芯开发板移植 IgH EtherCAT Master" href=https://kira-96.github.io/posts/%E9%BE%99%E8%8A%AF%E5%BC%80%E5%8F%91%E6%9D%BF%E7%A7%BB%E6%A4%8Digh-ethercat-master/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>EPICS的MODBUS模块的编译和使用</h2></header><div class=entry-content><p>前言 MODBUS是一种应用层消息传递协议，通常用于 I/O 系统通信和可编程逻辑控制器（PLC）通信。
链接类型 描述 MODBUS TCP TCP/IP 使用502端口 MODBUS RTU RTU通常通过串行通信链路运行，即RS-232、 RS-422 或 RS-485。RTU 使用额外的 CRC 进行数据包检查。协议直接将每个字节作为 8 个数据位传输，因此使用“二进制” 而不是 ASCII 编码。使用串行链路开始和结束时，消息帧是按时间而不是按特定字符检测的。 MODBUS ASCII 串行协议，通常在串行通信链路上运行，即 RS-232、RS-422 或 RS-485。串行 ASCII 使用额外的 LRC 数据包检查。该协议将每个字节编码为 2 个 ASCII 字符。消息帧的开始和结束由特定字符检测 （“:” 开始消息，CR/LF 结束消息）。该协议效率低于 Modbus RTU，但在某些环境中可能更可靠。 Modbus 提供对以下 4 种类型的数据的访问：
主表 对象类型 访问 说明 离散输入 1bit 只读 这种类型的数据可以由 I/O 系统提供。 线圈 1bit 读写 此类数据可由应用程序更改。 输入寄存器 16位字(2字节) 只读 这种类型的数据可以由 I/O 系统提供。 保持寄存器 16位字(2字节) 读写 此类数据可由应用程序更改。 Modbus 通信由从 Modbus 客户端发送到 Modbus 服务器的请求消息组成。服务器使用响应消息进行回复。Modbus 请求消息包含：
...</p></div><footer class=entry-footer><span title='2024-01-02 14:38:38 +0800 +0800'>一月 2, 2024</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;1296 字</footer><a class=entry-link aria-label="post link to EPICS的MODBUS模块的编译和使用" href=https://kira-96.github.io/posts/build-epics-module-modbus/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>交叉编译 ACAI
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>关于 ACAI ACAI 是一个C++封装的Channel Access协议应用开发接口（API），提供异步通道访问接口。
ACAI Channel Access Interface
EPICS Qt依赖ACAI提供的Channel Access接口。
前置步骤 这篇笔记是交叉编译EPICS和IOC内容的补充。
在进行下面步骤前，请完成配置交叉编译环境和编译 EPICS Base。
这里依旧以龙芯架构为例。
EPICS base 编译完成后，可以看到bin目录下有linux-loong64、linux-x86_64两个目录，linux-x86_64目录下比linux-loong64目录多出了许多perl脚本，我们需要把这些脚本复制到龙架构的目录下，下面编译需要用到。
shell ▼ 1 $ cp ./bin/linux-x86_64/*.pl ./bin/linux-loong64/ 编译 在EPICS-Qt安装中已经介绍过编译ACAI。这次是使用交叉编译方式，步骤略有不同。
sh ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 cd ~/loongson/ git clone https://github.com/andrewstarritt/acai.git cd acai vi configure/RELEASE.local # 修改交叉编译的目标架构，和EPICS base中保持一致 # EPICS_HOST_ARCH=linux-loong64 # 修改EPICS_BASE路径，例： EPICS_BASE=/home/ubuntu/loongson/base-7.0.8 # make LD=loongarch64-linux-gnu-ld CC=loongarch64-linux-gnu-gcc CCC=loongarch64-linux-gnu-g++ make # 等待编译完成 编译完成后可以在lib/linux-loong64/目录下找到libacai.so。
...</p></div><footer class=entry-footer><span title='2023-12-26 19:31:56 +0800 +0800'>十二月 26, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;71 字</footer><a class=entry-link aria-label="post link to 交叉编译 ACAI" href=https://kira-96.github.io/notes/cross-compiling-acai/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>交叉编译EPICS和IOC</h2></header><div class=entry-content><p>前言 之前已经讲过在龙芯3A5000(loongarch64)上编译运行EPICS，不过这种情况只适用于有完整开发环境的情况下进行编译。一些时候，我们只有编译器，而缺少make，perl等工具，比如一些开发板厂商提供的开发套件。这种情况下，就需要通过交叉编译(cross-compiling)的方式来编译EPICS。
这里以龙芯金龙2K500先锋开发板为例，我们使用Ubuntu-20.04作为构建系统，详细讲解如何构建出可以在开发板上运行的EPICS工具包，并部署在开发板上。
由于开发板上没有开发环境，即使编译出目标平台的EPICS Base，我们依然不能直接在开发板上创建和编译IOC。所以，我们还是使用Ubuntu-20.04作为构建系统，创建并编译IOC，最后在开发板上运行。
配置交叉编译环境 关于这一节，之前的文章已经详细讲过，参考配置交叉编译环境。
如果你使用的是其他开发套件，请按照开发手册安装配置好环境。
编译 EPICS Base 首先，下载、解压Base，参考以前的文章。
在龙芯3A5000(loongarch64)上编译运行EPICS中我已经详细讲解了如何在龙架构上编译EPICS，这次，需要在原来对源码修改的基础上，再增加对交叉编译的支持。
添加configure/os/CONFIG.linux-x86_64.linux-loong64
shell ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # CONFIG.linux-x86_64.linux-loong64 # # Definitions for linux-x86_64 host - linux-loong64 target builds # Sites may override these in CONFIG_SITE.linux-x86_64.linux-loong64 #------------------------------------------------------- VALID_BUILDS = Ioc Command GNU_TARGET = loongarch64-linux-gnu # prefix of compiler tools CMPLR_SUFFIX = CMPLR_PREFIX = $(addsuffix -,$(GNU_TARGET)) # Provide a link-time path for readline if needed OP_SYS_INCLUDES += $(READLINE_DIR:%=-I%/include) READLINE_LDFLAGS = $(READLINE_DIR:%=-L%/lib) RUNTIME_LDFLAGS_READLINE_YES_NO = $(READLINE_DIR:%=-Wl,-rpath,%/lib) RUNTIME_LDFLAGS += \ $(RUNTIME_LDFLAGS_READLINE_$(LINKER_USE_RPATH)_$(STATIC_BUILD)) SHRLIBDIR_LDFLAGS += $(READLINE_LDFLAGS) PRODDIR_LDFLAGS += $(READLINE_LDFLAGS) # Library flags STATIC_LDFLAGS_YES= -Wl,-Bstatic STATIC_LDFLAGS_NO= STATIC_LDLIBS_YES= -Wl,-Bdynamic STATIC_LDLIBS_NO= 添加configure/os/CONFIG_SITE.linux-x86_64.linux-loong64
...</p></div><footer class=entry-footer><span title='2023-12-12 16:26:35 +0800 +0800'>十二月 12, 2023</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;738 字</footer><a class=entry-link aria-label="post link to 交叉编译EPICS和IOC" href=https://kira-96.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91epics%E5%92%8Cioc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Linux LED子系统</h2></header><div class=entry-content><p>前言 Linux 内核提供了丰富的设备驱动接口，其中GPIO和LED属于是最基本的一类了。之前就已经讲过用户空间下的GPIO读写操作，LED设备的操作也基本相同。其实完全可以使用GPIO驱动去控制LED，但LED的驱动针对LED提供了更多的功能，一起来看一下吧。
配置设备树 设备树中的LED节点配置，例：
c ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* kernel/arch/arm/boot/dts/imx6ul-14x14-evk-c-emmc.dts */ leds { compatible = "gpio-leds"; pinctrl-names = "default"; status = "okay"; led1{ label = "led1"; gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led2{ label = "led2"; gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led3{ label = "heartbeat"; gpios = &lt;&amp;gpio5 5 GPIO_ACTIVE_LOW>; linux,default-trigger = "heartbeat"; }; }; 节点属性说明：
label：LED设备的名字，名字必须是唯一的。如果没有设置，则会使用节点的名字。
gpios：GPIO的编号，以及高低电平设置，GPIO_ACTIVE_LOW低电平点亮，GPIO_ACTIVE_HIGH高电平点亮。
default-state：默认状态，on/off。
linux,default-trigger：设置LED的触发器。backlight-背光灯，heartbeat-心跳灯，timer-定时，default-on-默认开状态，disk-activity-硬盘状态，gpio，none。
用户空间下的LED操作 注意：以下操作都需要root权限！
用户空间下的GPIO文件系统接口在/sys/class/leds/{label}目录下。
LED节点有以下属性可以配置：
...</p></div><footer class=entry-footer><span title='2023-11-11 15:45:11 +0800 +0800'>十一月 11, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;195 字</footer><a class=entry-link aria-label="post link to Linux LED子系统" href=https://kira-96.github.io/posts/linux-led%E5%AD%90%E7%B3%BB%E7%BB%9F/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://kira-96.github.io/tags/linux/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>© 2019-2025 <a href=/>kira&rsquo;s blog</a> · LICENSED under <a href=https://github.com/kira-96/kira-96.github.io/tree/main/LICENSE>CC-BY-4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>document.querySelectorAll(".fold-button").forEach(e=>{e.addEventListener("click",t=>{const n=t.target.closest(".mac-codeblock"),s=n.querySelector(".mac-content");s.classList.toggle("folded"),e.classList.toggle("folded")})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>