<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>✨kiraの博客</title><meta name=description content="This is kira's blog"><meta name=author content><link rel=canonical href=https://kira-96.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.7802032d20fa3b31547dfa2bc6209ee4715c482ccabd67740b739d16366107d4.css integrity="sha256-eAIDLSD6OzFUfforxiCe5HFcSCzKvWd0C3OdFjZhB9Q=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-32x32.png><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-180x180.png><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-76x76.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://kira-96.github.io/index.xml><link rel=alternate type=application/json href=https://kira-96.github.io/index.json><link rel=alternate hreflang=zh href=https://kira-96.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=manifest href=https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/manifest.json><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css><script src=https://fastly.jsdelivr.net/npm/live2d-widgets@0/autoload.js></script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><meta property="og:url" content="https://kira-96.github.io/"><meta property="og:site_name" content="✨kiraの博客"><meta property="og:title" content="✨kiraの博客"><meta property="og:description" content="This is kira's blog"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="✨kiraの博客"><meta name=twitter:description content="This is kira's blog"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"✨kiraの博客","url":"https://kira-96.github.io/","description":"This is kira's blog","logo":"https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico","sameAs":["https://github.com/kira-96/","https://space.bilibili.com/9258847","index.xml"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kira-96.github.io/ accesskey=h title="✨kiraの博客 (Alt + H)">✨kiraの博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kira-96.github.io/ title=🏠主页><span class=active>🏠主页</span></a></li><li><a href=https://kira-96.github.io/notes/ title=📓笔记><span>📓笔记</span></a></li><li><a href=https://kira-96.github.io/search/ title=🔍️搜索><span>🔍️搜索</span></a></li><li><a href=https://kira-96.github.io/archives/ title=🗃️存档><span>🗃️存档</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux LED子系统</h2></header><div class=entry-content><p>前言 Linux 内核提供了丰富的设备驱动接口，其中GPIO和LED属于是最基本的一类了。之前就已经讲过用户空间下的GPIO读写操作，LED设备的操作也基本相同。其实完全可以使用GPIO驱动去控制LED，但LED的驱动针对LED提供了更多的功能，一起来看一下吧。
配置设备树 设备树中的LED节点配置，例：
c ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* kernel/arch/arm/boot/dts/imx6ul-14x14-evk-c-emmc.dts */ leds { compatible = "gpio-leds"; pinctrl-names = "default"; status = "okay"; led1{ label = "led1"; gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led2{ label = "led2"; gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW>; default-state = "off"; }; led3{ label = "heartbeat"; gpios = &lt;&amp;gpio5 5 GPIO_ACTIVE_LOW>; linux,default-trigger = "heartbeat"; }; }; 节点属性说明：
label：LED设备的名字，名字必须是唯一的。如果没有设置，则会使用节点的名字。
gpios：GPIO的编号，以及高低电平设置，GPIO_ACTIVE_LOW低电平点亮，GPIO_ACTIVE_HIGH高电平点亮。
default-state：默认状态，on/off。
linux,default-trigger：设置LED的触发器。backlight-背光灯，heartbeat-心跳灯，timer-定时，default-on-默认开状态，disk-activity-硬盘状态，gpio，none。
用户空间下的LED操作 注意：以下操作都需要root权限！
用户空间下的GPIO文件系统接口在/sys/class/leds/{label}目录下。
LED节点有以下属性可以配置：
...</p></div><footer class=entry-footer><span title='2023-11-11 15:45:11 +0800 +0800'>十一月 11, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;195 字</footer><a class=entry-link aria-label="post link to Linux LED子系统" href=https://kira-96.github.io/posts/linux-led%E5%AD%90%E7%B3%BB%E7%BB%9F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>EPICS Qt安装</h2></header><div class=entry-content><p>前言 本文主要记录了EPICS Qt在Linux上的安装步骤。这里以loongnix操作系统为例，Ubuntu系统上编译安装步骤类似。
EPICS Qt是一个基于Qt的分层框架，使用Channel Access （CA） and PV Access（PVA）访问EPICS数据。它是为快速开发控制系统图形界面而设计的，最初是在澳大利亚同步加速器开发的。
安装EPICS 这里不再写具体步骤了，总之就是非常简单，下载、解压、编译即可。具体步骤可以参考以前的文章。
安装Qt 直接使用终端安装Qt
sh ▼ 1 2 3 4 5 sudo apt update sudo apt install qtbase5-dev qt5-qmake qtcreator sudo apt install qtdeclarative5-dev qttools5-dev # 安装Qt Svg库，编译QWT时需要用到 sudo apt install libqt5svg5-dev 安装QWT Qt EPICS推荐使用Qwt 6.1.4，如果在Ubuntu 20.04上直接通过终端安装也是这个版本。我使用Qwt 6.2.0编译，也是没有问题的，这里以Qwt 6.2.0为例。
最新测试：Qwt 6.3.0也可以用 ~
先下载Qwt的源码 下载Qwt-6.2.0。 下载完成后解压
sh ▼ 1 2 3 4 # 解压tar.bz2 tar -jxvf qwt-6.2.0.tar.bz2 # 解压zip unzip qwt-6.2.0.zip 解压完成后编译Qwt，使用QtCreator或者在终端使用qmake都可以。
然后手动将编译生成的文件复制到以下位置，例：
sh ▼ 1 2 3 4 5 6 7 # 复制编译生成的qwt sudo cp -r build-qwt-unknown-Release/lib/* /usr/lib/loongarch64-linux-gnu/ # 复制编译生成的designer插件 sudo cp build-qwt-unknown-Release/designer/plugins/designer/libqwt_designer_plugin.so /usr/lib/loongarch64-linux-gnu/qt5/plugins/designer/ # 复制qwt头文件 sudo mkdir /usr/include/qwt sudo cp qwt-6.2.0/src/*.h /usr/include/qwt 安装ACAI ACAI Channel Access Interface
...</p></div><footer class=entry-footer><span title='2023-05-04 15:06:56 +0800 +0800'>五月 4, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;378 字</footer><a class=entry-link aria-label="post link to EPICS Qt安装" href=https://kira-96.github.io/posts/epics-qt%E5%AE%89%E8%A3%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>龙芯2K500开发板上实现的呼吸灯效果</h2></header><div class=entry-content><p>前言 本来这篇文章应该在上周就写完的，不过突然被安排出差，一直忙到了现在，终于可以静下心来做些其它事情。
之前和龙芯3A5000主机一起送过来的还有一块龙芯2K500的迷你开发板，整个板子不到巴掌大小。之前只是简单做了上电启动，这次拿到了比较完整的开发资料，可以尝试为开发板编写一些程序了。
由于暂时没有屏幕，只能先试着做一些其它的事情，如通信和IO控制，其中最简单，最基础的就是LED灯的控制。然后我就发现，这个板子居然有一颗可以调节亮度的LED灯！没错，之前做的LED控制都只能进行开关操作，而可以调节亮度，意味着可以做出更多的显示效果，这次我就做了一个呼吸灯的效果。
然后，我也简单了解了一下这种亮度调节的原理，实际上就是通过调节PWM输出的占空比，改变一个周期内输出的高低电平所占的比例，实现控制LED灯亮度的效果。由于引脚输出的电压是固定的，所以不能通过改变电平来控制亮度，而改变高低电平的占空比则是另一种思路，嵌入式设备的屏幕背光亮度调节也是基于同样的原理。
开发板上电启动、连接串口终端 由于暂时没有屏幕，想要和开发板进行交互就只能通过终端的方式，通常开发板都会有调试串口，我们先通过串口终端登录设备，配置好网口IP地址后，再通过网络连接登录设备。
串口的连接方式如下图：
将绿、白、黑三色线以图中方式接好（红线不用接），USB端插入到电脑，应该不需要装驱动，电脑可以直接识别出串口设备。
打开串口终端工具，比如Windows MobaXterm，linux minicom等，我比较喜欢用putty。
配置好端口，设置
波特率：115200
数据位：8位
停止位：1位
校验：无
硬件流控：无
然后给开发板接通电源，就可以看到调试输出信息了。
查看系统信息，可以看到运行的是安装了PREEMPT_RT补丁的实时操作系统。
sh ▼ 1 2 3 [root@LS-GD ~]# uname -a Linux LS-GD 5.10.0.lsgd-g434b00a6badf #1 PREEMPT Wed Sep 14 12:57:58 CST 2022 loongarch64 GNU/Linux [root@LS-GD ~]# 配置交叉编译环境 2K500开发板是loongarch64架构的嵌入式板卡。下载好对应的交叉编译工具链后，解压到系统/opt/目录下。按手册来就好~
sh ▼ 1 $ sudo tar -xf toolchain-loongarch64-linux-gnu-gcc8-host-x86_64-2022-07-18.tar.xz -C /opt/ 然后我们需要将交叉编译器添加到系统路径，方便我们接下来使用。
这里我直接将配置写成脚本，方便下次使用。
sh ▼ 1 2 3 4 5 6 7 8 $ cd /opt/toolchain-loongarch64-linux-gnu-gcc8-host-x86_64-2022-07-18 # 创建脚本 $ sudo touch environment-setup-loongarch64-linux-gnu # 添加可执行权限 $ sudo chmod +x environment-setup-loongarch64-linux-gnu # 修改脚本内容 $ sudo vi environment-setup-loongarch64-linux-gnu # 内容如下~ sh ▼ 1 2 3 4 5 6 7 8 # environment-setup-loongarch64-linux-gnu CC_PREFIX=/opt/toolchain-loongarch64-linux-gnu-gcc8-host-x86_64-2022-07-18 export PATH=$CC_PREFIX/bin:$PATH export LD_LIBRARY_PATH=$CC_PREFIX/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH=$CC_PREFIX/loongarch64-linux-gnu/lib64:$LD_LIBRARY_PATH export ARCH=loongarch export CROSS_COMPILE=loongarch64-linux-gnu- 接下来测试一下交叉编译环境
...</p></div><footer class=entry-footer><span title='2023-02-19 10:23:19 +0800 +0800'>二月 19, 2023</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;472 字</footer><a class=entry-link aria-label="post link to 龙芯2K500开发板上实现的呼吸灯效果" href=https://kira-96.github.io/posts/%E9%BE%99%E8%8A%AF2k500%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%BC%E5%90%B8%E7%81%AF%E6%95%88%E6%9E%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>龙芯3A5000(LoongArch64)上编译运行EPICS</h2></header><div class=entry-content><p>前言 之前尝试过在龙芯3A4000上编译运行EPICS，由于3A4000还是mips64指令集，而3A5000则是龙芯的自主指令集loongarch64，适配起来步骤也会有所不同。
这次使用的是龙博特龙芯3A5000电脑主机。
虽然EPICS官方并没有适配loongarch和mips64，无法做到开箱即用，但只要有gcc、g++、make、perl这些工具，理论上就能编译运行EPICS，在开始编译前，确保你的设备上已经装好了这些工具。
关于如何称呼「龙架构」，龙芯社区也有一些讨论。最初我直接使用loongarch64，后来也使用过la64作为简写，直到我看到如何称呼龙架构？，我觉得有必要和社区保持一致，后续统一使用 loong64 作为架构标识。
下载 base 这里我们就以目前最新版本7.0.7为例，其它版本的Base也类似。
shell ▼ 1 2 3 $ cd ~/下载/ $ wget https://epics.anl.gov/download/base/base-7.0.7.tar.gz $ tar -xzvf base-7.0.7.tar.gz 你可以在你觉得合适的位置编译安装Base，这里按我们的习惯，放在/usr/local/epics目录下。
shell ▼ 1 2 $ mkdir /usr/local/epics $ mv base-7.0.7 /usr/local/epics/ 编译 按照一般步骤，现在就可以开始编译了，我们可以先尝试一下，看看是什么结果。
shell ▼ 1 2 3 $ cd /usr/local/epics/base-7.0.7/ # 执行 `make` 命令 $ make 不出所料，果然失败了，输出的错误和在3A4000上编译时的错误也有一些不同。
下面是在3A4000上编译时输出的错误：
下面一行报错是差不多的，在loongarch64上编译却多了上面一行报错，意思就是没有识别出loongarch64架构。
但是先不要慌，这里同时也给出了报错的位置，让我们看看EpicsHostArch.pl里写了些什么。
shell ▼ 1 $ vi ./src/tools/EpicsHostArch.pl 它其实就是一个perl脚本，用来判断当前的系统和cpu架构，而loongarch64显然没有做适配，所以就出现了上面错误。
“Architecture ’loongarch64-linux-gnu-thread-multi’ not recognized”
既然识别不了loongarch64，那我们就手动添加一行，让它可以识别就行了，即使看不太懂上面的脚本也没关系，看个半懂就行了。
perl ▼ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 sub HostArch { my $arch = $Config{archname}; for ($arch) { return 'linux-x86_64' if m/^x86_64-linux/; return 'linux-x86' if m/^i[3-6]86-linux/; return 'linux-arm' if m/^arm-linux/; return 'linux-aarch64' if m/^aarch64-linux/; return 'linux-ppc64' if m/^powerpc64-linux/; return 'linux-loong64' if m/^loongarch64-linux/; return 'windows-x64' if m/^MSWin32-x64/; return 'win32-x86' if m/^MSWin32-x86/; return "cygwin-x86_64" if m/^x86_64-cygwin/; return "cygwin-x86" if m/^i[3-6]86-cygwin/; return 'solaris-sparc' if m/^sun4-solaris/; return 'solaris-x86' if m/^i86pc-solaris/; my ($kernel, $hostname, $release, $version, $cpu) = uname; if (m/^darwin/) { for ($cpu) { return 'darwin-x86' if m/^x86_64/; return 'darwin-aarch64' if m/^arm64/; } die "$0: macOS CPU type '$cpu' not recognized\n"; } die "$0: Architecture '$arch' not recognized\n"; } } 我们在上面位置添加一行内容，来让它可以识别loongarch64架构。
...</p></div><footer class=entry-footer><span title='2023-02-01 15:51:40 +0800 +0800'>二月 1, 2023</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;1031 字</footer><a class=entry-link aria-label="post link to 龙芯3A5000(LoongArch64)上编译运行EPICS" href=https://kira-96.github.io/posts/%E9%BE%99%E8%8A%AF3a5000loongarch64%E4%B8%8A%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cepics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux GPIO 操作其一</h2></header><div class=entry-content><p>前言 由于换了新的工作，我的工作方向也有了很大的变化，之前基本上是单纯的写代码，现在则经常需要和硬件设备交互，开发平台也转到了Linux+Qt。硬件设备的控制，其中最基本的就是LED灯以及一些开关继电器的操作，其本质就是GPIO的操作。考虑到系统的精简和成本控制，最好是可以直接通过Linux系统去控制，当然也有其它替代方案，比如使用支持Modbus协议的IO模块。关于Modbus的使用，后面有空再讲，这里就记录一下最简单的Linux系统下的GPIO控制，用户空间下的GPIO文件系统接口。
在此之前，有必要再了解一下GPIO的概念。
“通用输入/输出”（GPIO）是一种灵活的软件控制数字信号。它们由多种芯片提供，对于使用嵌入式和定制硬件的Linux开发人员来说很熟悉。每个GPIO代表一个连接到特定引脚的位，即球栅阵列（BGA）封装上的“球”。电路板示意图显示了哪些外部硬件连接到哪些GPIO。驱动程序可以通用地编写，以便板设置代码将这样的引脚配置数据传递给驱动程序。
A “General Purpose Input/Output” (GPIO) is a flexible software-controlled digital signal. They are provided from many kinds of chip, and are familiar to Linux developers working with embedded and custom hardware. Each GPIO represents a bit connected to a particular pin, or “ball” on Ball Grid Array (BGA) packages. Board schematics show which external hardware connects to which GPIOs. Drivers can be written generically, so that board setup code passes such pin configuration data to drivers.
...</p></div><footer class=entry-footer><span title='2023-01-12 13:33:37 +0800 +0800'>一月 12, 2023</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;516 字</footer><a class=entry-link aria-label="post link to Linux GPIO 操作其一" href=https://kira-96.github.io/posts/linux-gpio%E6%93%8D%E4%BD%9C%E5%85%B6%E4%B8%80/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WSL libcuda.so.1 is not a symbolic link 的解决方法</h2></header><div class=entry-content><p>问题描述 在使用 WSL 更新软件包的时候经常会遇到这样一个报错
shell ▼ 1 /sbin/ldconfig.real: /usr/lib/wsl/lib/libcuda.so.1 is not a symbolic link 意思是说 /usr/lib/wsl/lib/libcuda.so.1 不是一个符号链接。
问题分析 通过名字可以判断这应该是nVidia显卡驱动相关的库，进入 /usr/lib/wsl/lib/ 目录，可以看到有 libcuda.so、libcuda.so.1、libcuda.so.1.1 三个文件，都是文件形式，而通过报错我们知道 libcuda.so、libcuda.so.1 应该是符号链接文件。
...</p></div><footer class=entry-footer><span title='2022-02-09 08:48:30 +0800 +0800'>二月 9, 2022</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;432 字</footer><a class=entry-link aria-label="post link to WSL libcuda.so.1 is not a symbolic link 的解决方法" href=https://kira-96.github.io/posts/wsl-libcuda.so.1-is-not-a-symbolic-link-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>交叉编译适用于 iMX6UL 的 x11vnc</h2></header><div class=entry-content><p>前言 由于这半年来一直在做嵌入式Linux系统软件开发工作，所以经常和嵌入式设备打交道，最早接触的嵌入式Linux应该就是树莓派了，而我的树莓派一般也不接屏幕，基本上都使用VNC远程连接，所以就想着能不能把VNC也移植到嵌入式设备上，最后找到了x11vnc。
...</p></div><footer class=entry-footer><span title='2022-02-06 11:06:12 +0800 +0800'>二月 6, 2022</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1039 字</footer><a class=entry-link aria-label="post link to 交叉编译适用于 iMX6UL 的 x11vnc" href=https://kira-96.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%80%82%E7%94%A8%E4%BA%8E-imx6ul-%E7%9A%84-x11vnc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>开始一份新工作</h2></header><div class=entry-content><p>开始一份新工作 好久没有更新博客了，最近几个月都在忙新工作的事情，虽然只是短短3个月，但回想起来已经是很久之前了。从4月份面试，然后体检，提交各种材料证明，到5月份工作交接，6月份正式离职进入新单位，搬家等等，这几个月真是忙的有点喘不过气。即使到了新的单位，也没有闲下来的时间，来了之后就要上手做项目，到这周为止，项目总算初步完成，这才有时间来自我整理一下。即使5月份买了PS5游戏机也没怎么有时间玩，没什么游戏是一方面，忙也是一方面。
...</p></div><footer class=entry-footer><span title='2021-07-11 11:14:52 +0800 +0800'>七月 11, 2021</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1315 字</footer><a class=entry-link aria-label="post link to 开始一份新工作" href=https://kira-96.github.io/posts/%E5%BC%80%E5%A7%8B%E4%B8%80%E4%BB%BD%E6%96%B0%E5%B7%A5%E4%BD%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在 Windows 上编译 MITK</h2></header><div class=entry-content><p>前言 The Medical Imaging Interaction Toolkit (MITK)是一个免费的开源软件，用于开发交互式医学影像处理软件。最近突然安排我做相关的一些工作，首先就要从编译开始，当然官网也有编译好的版本，可以直接下载使用。本来在Windows上编译这种开源的软件就很麻烦，在加上github上的东西下载巨慢，常常出错，折腾了好久才编译完成，这里就记录一下踩过的那些坑。
...</p></div><footer class=entry-footer><span title='2021-03-29 09:54:57 +0800 +0800'>三月 29, 2021</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;1559 字</footer><a class=entry-link aria-label="post link to 在 Windows 上编译 MITK" href=https://kira-96.github.io/posts/build-mitk-on-windows/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gitea 安装使用</h2></header><div class=entry-content><p>前言 今天偶然看到一个新的开源的git服务软件Gitea，一看到界面，瞬间就爱了，因为之前我自己用的是gitblit，界面比较简单，主要是用来管理公司的一些小项目。今天看到Gitea之后，就决定迁移到过去，简单折腾了一下，配置起来比gitblit要简单一些，但界面却更加漂亮了，总体上看起来比较像github，并且还支持主题系统，很合我的胃口。
下载二进制包 首先去下载对应系统的二进制包，可以去github或者官网下载最新的发布版本。
我是在windows下配置的，所以选择下载windows版的可执行程序。
...</p></div><footer class=entry-footer><span title='2021-03-22 10:07:35 +0800 +0800'>三月 22, 2021</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1084 字</footer><a class=entry-link aria-label="post link to Gitea 安装使用" href=https://kira-96.github.io/posts/install-gitea/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://kira-96.github.io/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://kira-96.github.io/page/3/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>© 2019-2025 <a href=/>kira&rsquo;s blog</a> · LICENSED under <a href=https://github.com/kira-96/kira-96.github.io/tree/main/LICENSE>CC-BY-4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>document.querySelectorAll(".fold-button").forEach(e=>{e.addEventListener("click",t=>{const n=t.target.closest(".mac-codeblock"),s=n.querySelector(".mac-content");s.classList.toggle("folded"),e.classList.toggle("folded")})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>