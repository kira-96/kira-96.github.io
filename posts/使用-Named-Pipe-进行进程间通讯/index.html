<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.82.0" />

  <title> 使用 Named Pipe 进行进程间通讯 |  kira&#39;s 博客</title>
  <meta name="description" content="Named Pipe简单使用">
  <link rel="stylesheet" href="https://kira-96.github.io/css/simpleness.css">
  <link rel="canonical" href="https://kira-96.github.io/posts/%E4%BD%BF%E7%94%A8-Named-Pipe-%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/">
  <link rel="alternate" type="application/rss+xml" href="" title="kira&#39;s 博客">
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">
  
  <meta name="theme-color" content="#ffffff">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="使用 Named Pipe 进行进程间通讯">
  <link rel="apple-touch-icon" sizes="152x152" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/icons/apple-icon-180x180.png">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon.ico">
  <link rel="icon" sizes="16x16" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-16x16.png">
  <link rel="icon" sizes="32x32" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-32x32.png">
  <link rel="icon" sizes="96x96" href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/favicon-96x96.png">
  <link rel="manifest"  href="https://cdn.jsdelivr.net/gh/kira-96/kira-96.github.io@gh-pages/manifest.json">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
  <script defer src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
</head>


<body>
  <header class="menus">
  

  <nav >
    
    <a href="/"> Home</a>
    
    <a href="/notes/"> Notes</a>
    
  </nav>

  <nav class="fontawesome">
    
    <a href="https://github.com/kira-96/" target="_blank">
        <i title="GitHub" class="fab fa-github"></i>
    </a>
    
    
    <a href="https://kira-96.github.io/index.xml" target="_blank">
        <i title="RSS" class="fas fa-rss"></i>
    </a>
    
  </nav>
  
  
  <div class="hidden description">kira's blog</div>
  
</header>

<article class="article">
  <header>
    <h1 style="text-align: center;" >使用 Named Pipe 进行进程间通讯</h1>

    <div class="post-meta">
    
      <time datetime="2019-11-15T19:12:30&#43;08:00">November 15, 2019</time> &nbsp; 
    

     &nbsp;

    
    
      <i class="far fa-eye"></i>
      <span id="/posts/%E4%BD%BF%E7%94%A8-Named-Pipe-%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/" class="leancloud_visitors" data-flag-title="使用 Named Pipe 进行进程间通讯">
          <span class="leancloud-visitors-count">  </span>
      </span> &nbsp;
    
    

    
      <i class="far fa-clock"></i>
      
      
      

      
        5 min
      
      16 s
      &nbsp;
    

    
      <i class="fas fa-folder"></i>
      
      <a href="/categories/%E7%BC%96%E7%A8%8B">编程</a>
      &nbsp;
      
    
    </div>
  </header>

   

  <div class="text">
    <p>这段时间公司的一个项目打算使用<code>Named Pipe</code>进行进程间的通讯，刚好花了点时间了解了一下，这里做一下笔记。</p>
<p>Named Pipe（命名管道），顾名思义，是通过在两个进程间搭建一个管道来进行通讯，这种方式的好处在于两者可以进行<strong>全双工</strong>的通讯，服务端也可以通过管道向客户端发送消息，对于两个进程之间的通讯来说再合适不过了，使用起来也相对比较灵活。</p>
<h2 id="服务端server">服务端（Server）</h2>
<p><strong>Named Pipe 命名空间</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System.IO.Pipes;
</code></pre></div><p><strong>创建管道</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">PipeSecurity security = <span style="color:#66d9ef">new</span> PipeSecurity();  <span style="color:#75715e">// 管道权限
</span><span style="color:#75715e">// 设置规则，只有用户admin可以对管道进行读写，其它用户无权访问
</span><span style="color:#75715e"></span>security.AddAccessRule(<span style="color:#66d9ef">new</span> PipeAccessRule(<span style="color:#e6db74">&#34;admin&#34;</span>, PipeAccessRights.ReadWrite, AccessControlType.Allow));

NamedPipeServerStream server = <span style="color:#66d9ef">new</span> NamedPipeServerStream(
    <span style="color:#e6db74">&#34;SimpleServer&#34;</span>,  <span style="color:#75715e">// pipe name
</span><span style="color:#75715e"></span>    PipeDirection.InOut,  <span style="color:#75715e">// 数据传输方向，这里使用双工通讯
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">1</span>,               <span style="color:#75715e">// MaxNumberOfServerInstance
</span><span style="color:#75715e"></span>    PipeTransmissionMode.Byte,  <span style="color:#75715e">// 字节流传输
</span><span style="color:#75715e"></span>    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
    <span style="color:#ae81ff">4096</span>,  <span style="color:#75715e">// 输入缓冲大小
</span><span style="color:#75715e"></span>    <span style="color:#ae81ff">4096</span>,  <span style="color:#75715e">// 输出缓冲大小
</span><span style="color:#75715e"></span>    security);  <span style="color:#75715e">// 管道访问权限，这里只做笔记，通常不需要设置
</span></code></pre></div><p>管道创建好之后还不能立刻发送数据，因为管道的另一端（客户端）还没有连接，所以服务端需要等待连接。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">server.WaitForConnection();  <span style="color:#75715e">// 阻塞方式
</span></code></pre></div><p>这里使用非阻塞的方式等待连接，当然也可以用阻塞的方式等待连接，不过需要放到一个新的线程中，避免将主线程阻塞。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">server.BeginWaitForConnection(<span style="color:#66d9ef">new</span> AsyncCallback(WaitConnectionCallback), server);  <span style="color:#75715e">// 非阻塞方式
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> WaitConnectionCallback(IAsyncResult asyncResult)
{
    NamedPipeServerStream server = asyncResult.AsyncState <span style="color:#66d9ef">as</span> NamedPipeServerStream;
    server.EndWaitForConnection(asyncResult);

    StartListen(server);
}


<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> StartListen(NamedPipeServerStream server)
{
    Task.Run(<span style="color:#66d9ef">async</span> () =&gt;
    {
        <span style="color:#66d9ef">int</span> bytesToRead;
        <span style="color:#66d9ef">byte</span>[] buffer;

        <span style="color:#75715e">// server.WaitForConnection();
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
        {
            <span style="color:#66d9ef">try</span>
            {
                bytesToRead = <span style="color:#ae81ff">256</span> * server.ReadByte();
                bytesToRead += server.ReadByte();

                <span style="color:#75715e">// 演示
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 将收到的数据立马发送出去
</span><span style="color:#75715e"></span>                server.WriteByte((<span style="color:#66d9ef">byte</span>)(bytesToRead / <span style="color:#ae81ff">256</span>));
                server.WriteByte((<span style="color:#66d9ef">byte</span>)(bytesToRead % <span style="color:#ae81ff">256</span>));

                buffer = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span>[bytesToRead];
                server.Read(buffer, <span style="color:#ae81ff">0</span>, bytesToRead);  <span style="color:#75715e">// 读取消息
</span><span style="color:#75715e"></span>
                <span style="color:#75715e">// 演示
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// 将收到的数据立马发送出去
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">await</span> server.WriteAsync(buffer, <span style="color:#ae81ff">0</span>, bytesToRead);
            }
            <span style="color:#66d9ef">catch</span> (System.IO.IOException)
            {
                <span style="color:#75715e">// break if another pipe end closed
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
            }
            <span style="color:#66d9ef">catch</span> (Exception)
            {
                <span style="color:#66d9ef">break</span>;
            }

            <span style="color:#75715e">// 处理数据
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">string</span> content = Encoding.UTF8.GetString(buffer);
            Console.WriteLine(content);
        }

        server.Disconnect();  <span style="color:#75715e">// 断开连接
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 重新等待连接
</span><span style="color:#75715e"></span>        server.BeginWaitForConnection(<span style="color:#66d9ef">new</span> AsyncCallback(WaitConnectionCallback), server);
    });
}
</code></pre></div><p>在客户端连接之后，立马启动一个新的线程循环读取来自客户端的消息，这里的消息前两个字节指定了消息的长度。同时将收到的消息马上返回到管道的另一端（这里用于测试是否真的是全双工工作）。</p>
<p>最后将消息的读取放到<code>try{ ... } catch(...){ ... }</code>中，因为并没有消息或者事件通知服务端客户端已经断开连接。但当客户端断开之后，服务端在读取时会抛出<code>IOException</code>，可以通过抓取这个错误来判断管道是否已经断开。</p>
<p>当客户端断开之后，中断读取循环，服务端也断开连接，并再次等待客户端连接。</p>
<h2 id="客户端client">客户端（Client）</h2>
<p><strong>创建客户端</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">NamedPipeClientStream client = <span style="color:#66d9ef">new</span> NamedPipeClientStream(
    <span style="color:#e6db74">&#34;.&#34;</span>, <span style="color:#75715e">// The name of the remote computer, &#34;.&#34; 指本机
</span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;SimpleServer&#34;</span>,  <span style="color:#75715e">// pipe name
</span><span style="color:#75715e"></span>    PipeDirection.InOut,  <span style="color:#75715e">// 数据传输方向
</span><span style="color:#75715e"></span>    PipeOptions.Asynchronous | PipeOptions.WriteThrough);
</code></pre></div><p><strong>连接到服务端</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">client.Connect();  <span style="color:#75715e">// 阻塞方式
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">Task.Run(() =&gt;
{
    <span style="color:#66d9ef">int</span> bytesToRead;
    <span style="color:#66d9ef">byte</span>[] buffer;

    client.Connect();  <span style="color:#75715e">// 连接管道
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
    {
        <span style="color:#66d9ef">try</span>
        {
            <span style="color:#75715e">// 读取消息长度
</span><span style="color:#75715e"></span>            bytesToRead = <span style="color:#ae81ff">256</span> * client.ReadByte();
            bytesToRead += client.ReadByte();

            buffer = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span>[bytesToRead];
            client.Read(buffer, <span style="color:#ae81ff">0</span>, bytesToRead);  <span style="color:#75715e">// 读取消息
</span><span style="color:#75715e"></span>        }
        <span style="color:#66d9ef">catch</span> (System.IO.IOException)
        {
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">catch</span> (Exception)
        {
            <span style="color:#66d9ef">break</span>;
        }

        <span style="color:#75715e">// 处理消息
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">string</span> content = Encoding.UTF8.GetString(buffer);
        Console.WriteLine(content);
    }

    client.Close();
});
</code></pre></div><p>这里使用一个新的线程去连接管道服务端，连接成功后循环读取来自服务端的消息。</p>
<p><strong>客户端发送</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">string</span> text = <span style="color:#e6db74">&#34;Hello&#34;</span>;
<span style="color:#66d9ef">byte</span>[] bytes = System.Text.Encoding.UTF8.GetBytes(text);

client.WriteByte((<span style="color:#66d9ef">byte</span>)(bytes.Length / <span style="color:#ae81ff">256</span>));  <span style="color:#75715e">// 发送消息头
</span><span style="color:#75715e"></span>client.WriteByte((<span style="color:#66d9ef">byte</span>)(bytes.Length % <span style="color:#ae81ff">256</span>));
client.Write(bytes, <span style="color:#ae81ff">0</span>, bytes.Length);          <span style="color:#75715e">// 发送消息
</span><span style="color:#75715e"></span>
text = <span style="color:#e6db74">&#34;World&#34;</span>;
bytes = System.Text.Encoding.UTF8.GetBytes(text);

client.WriteByte((<span style="color:#66d9ef">byte</span>)(bytes.Length / <span style="color:#ae81ff">256</span>));  <span style="color:#75715e">// 发送消息头
</span><span style="color:#75715e"></span>client.WriteByte((<span style="color:#66d9ef">byte</span>)(bytes.Length % <span style="color:#ae81ff">256</span>));
client.Write(bytes, <span style="color:#ae81ff">0</span>, bytes.Length);          <span style="color:#75715e">// 发送消息
</span></code></pre></div><h2 id="总结">总结</h2>
<p>总的来说，<code>Named Pipe</code>使用还是比较简单的，结合序列化就可以直接在两个进程中传递消息对象了。需要注意的是一个服务端只能有一个客户端连接，而且在客户端断开连接之后，服务端也需要断开连接，并重新等待客户端连接，不然再有客户端尝试连接管道也无法建立。</p>
<p><strong>参考</strong></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication">How to: Use Named Pipes for Network Interprocess Communication</a></p>

  </div>

  <footer>
    <hr class="end-line">

    

    
    <div class="post-tags">
      <i class="fas fa-tags"></i>
      
        <a href="/tags/C">C#</a>
        &nbsp;
      
        <a href="/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a>
        &nbsp;
      
    </div>
    

    
    
    <div class="releated-posts">
      <h3>Related Posts</h3>
      
      <i class="fas fa-paperclip"></i>
      <a href="/posts/Hprose-C_-%E5%88%9D%E6%8E%A2/">Hprose C# 初探</a>
      <br>
      
      <i class="fas fa-paperclip"></i>
      <a href="/posts/Thrift-C_-%E5%88%9D%E6%8E%A2/">Thrift C# 初探</a>
      <br>
      
      <i class="fas fa-paperclip"></i>
      <a href="/posts/gRPC-C_-%E5%88%9D%E6%8E%A2/">gRPC C# 初探</a>
      <br>
      
      <i class="fas fa-paperclip"></i>
      <a href="/posts/WPF%E5%92%8CMFC%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/">WPF和MFC进程间传递数据</a>
      <br>
      
      <i class="fas fa-paperclip"></i>
      <a href="/posts/WPF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Windows%E6%B6%88%E6%81%AF/">WPF如何处理Windows消息</a>
      <br>
      
    </div>
    
  </footer>

  <div class="comments">



  <div class="comments-item comments-valine" >
    
    
    
    <div id="vcomments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script type="text/javascript">
      new Valine({
          el: '#vcomments',
          highlight: false,
          lang: "zh-CN",
          appId: "X8gbfFnXlzbwF0YQQ91rSogz-gzGzoHsz",
          appKey: "ljO0GYMaeqs5KWK2vCtk1Ii8",
          placeholder: "在这里写下你的留言丨支持 Markdown 语法",
          requiredFields: ["nick","mail"],
          avatar: "mp",
          visitor:  true ,
          recordIP: true
      });
    </script>
    <script>
      if(window.location.hash){
          var checkExist = setInterval(function() {
             if ($(window.location.hash).length) {
                $('html, body, article').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
                clearInterval(checkExist);
             }
          }, 100);
      }
    </script>
  </div>

</div>

</article>


</body>
<div class="foot">
  
  
    &copy; 2019 - 2021 &#183; 
    <a href="/">kira-96</a> · Theme <a href="https://github.com/RainerChiang/simpleness">Simpleness</a>|Powered by <a href="https://gohugo.io/">Hugo</a> &#183;
    <a href="#"><i class="fas fa-chevron-up"></i></a>
  

  
</div>

<script src="/js/lazyload.min.js"></script>
<script>
  var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });
</script>


</html>
